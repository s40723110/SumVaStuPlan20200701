var tipuesearch = {"pages": [{'title': 'Date', 'text': '', 'tags': '', 'url': 'Date.html'}, {'title': '7月2號', 'text': '\xa0 \xa0 進度 :\xa0 目前在機台的Z軸校正上想要讓他對齊底板 ( 一張紙的空隙 ) ，但是發現裡面的預寫程式設定的 Z:337 一直無法被改變，所以我和國龍想要導入裡面的程式並加以修改，於是根據學長留下的專題報告書中所寫的內容想要導入 Configuration.h 檔案去修改，但是發現程式內容與書上有很大區別 (華倞學長後來跟我們說那是因為有很多新的功能 )\xa0，於是想要用 pronterface 去動它的Z軸設定。之後還有平台的不平解決方案代處理。 \n \n \n \n 搜尋的相關網址 : \n https://forum.duet3d.com/topic/3800/resetting-the-origin-of-a-delta \n https://www.pronterface.com/ \n https://www.repetier.com/firmware/v100/config.php? \n http://download.repetier.com/files/host/win/setupRepetierHost_2_1_6.exe \n http://kliment.kapsi.fi/printrun/Printrun-win-18Nov2017.zip \n https://reprap.org/wiki/List_of_Firmware \n https://www.hindawi.com/journals/je/2019/5175323/ \n \n 七月學習事項 : \n (a) 學會複製磁區、網路 \n (b) clonezilia \n (c) keras 、 pytorch \n \n \n', 'tags': '', 'url': '7月2號.html'}, {'title': '7月4號', 'text': '目標 :\xa0 推導 delta printer 的正向與逆向運動方程式, 弄懂之後, 寫網誌或整理成網頁內容 \n https://www.marginallyclever.com/other/samples/fk-ik-test.html \n https://gist.github.com/hugs/4231272 \n \n \n \n 圖源 :\xa0 https://www.marginallyclever.com/other/samples/fk-ik-test.html \n \n # Original code from\n# http://forums.trossenrobotics.com/tutorials/introduction-129/delta-robot-kinematics-3276/\n# License: MIT\n\nimport math\n\n# Specific geometry for bitbeambot:\n# http://flic.kr/p/cYaQah\ne  =  26.0\nf  =  69.0\nre = 128.0\nrf =  88.0\n\n# Trigonometric constants\ns      = 165*2\nsqrt3  = math.sqrt(3.0)\npi     = 3.141592653\nsin120 = sqrt3 / 2.0\ncos120 = -0.5\ntan60  = sqrt3\nsin30  = 0.5\ntan30  = 1.0 / sqrt3\n\n# Forward kinematics: (theta1, theta2, theta3) -> (x0, y0, z0)\n#   Returned {error code,theta1,theta2,theta3}\ndef forward(theta1, theta2, theta3):\n    x0 = 0.0\n    y0 = 0.0\n    z0 = 0.0\n    \n    t = (f-e) * tan30 / 2.0\n    dtr = pi / 180.0\n    \n    theta1 *= dtr\n    theta2 *= dtr\n    theta3 *= dtr\n    \n    y1 = -(t + rf*math.cos(theta1) )\n    z1 = -rf * math.sin(theta1)\n    \n    y2 = (t + rf*math.cos(theta2)) * sin30\n    x2 = y2 * tan60\n    z2 = -rf * math.sin(theta2)\n    \n    y3 = (t + rf*math.cos(theta3)) * sin30\n    x3 = -y3 * tan60\n    z3 = -rf * math.sin(theta3)\n    \n    dnm = (y2-y1)*x3 - (y3-y1)*x2\n    \n    w1 = y1*y1 + z1*z1\n    w2 = x2*x2 + y2*y2 + z2*z2\n    w3 = x3*x3 + y3*y3 + z3*z3\n    \n    # x = (a1*z + b1)/dnm\n    a1 = (z2-z1)*(y3-y1) - (z3-z1)*(y2-y1)\n    b1= -( (w2-w1)*(y3-y1) - (w3-w1)*(y2-y1) ) / 2.0\n    \n    # y = (a2*z + b2)/dnm\n    a2 = -(z2-z1)*x3 + (z3-z1)*x2\n    b2 = ( (w2-w1)*x3 - (w3-w1)*x2) / 2.0\n    \n    # a*z^2 + b*z + c = 0\n    a = a1*a1 + a2*a2 + dnm*dnm\n    b = 2.0 * (a1*b1 + a2*(b2 - y1*dnm) - z1*dnm*dnm)\n    c = (b2 - y1*dnm)*(b2 - y1*dnm) + b1*b1 + dnm*dnm*(z1*z1 - re*re)\n    \n    # discriminant\n    d = b*b - 4.0*a*c\n    if d < 0.0:\n        return [1,0,0,0] # non-existing povar. return error,x,y,z\n    \n    z0 = -0.5*(b + math.sqrt(d)) / a\n    x0 = (a1*z0 + b1) / dnm\n    y0 = (a2*z0 + b2) / dnm\n\n    return [0,x0,y0,z0]\n\n# Inverse kinematics\n# Helper functions, calculates angle theta1 (for YZ-pane)\ndef angle_yz(x0, y0, z0, theta=None):\n    y1 = -0.5*0.57735*f # f/2 * tg 30\n    y0 -= 0.5*0.57735*e # shift center to edge\n    # z = a + b*y\n    a = (x0*x0 + y0*y0 + z0*z0 + rf*rf - re*re - y1*y1) / (2.0*z0)\n    b = (y1-y0) / z0\n\n    # discriminant\n    d = -(a + b*y1)*(a + b*y1) + rf*(b*b*rf + rf)\n    if d<0:\n        return [1,0] # non-existing povar.  return error, theta\n\n    yj = (y1 - a*b - math.sqrt(d)) / (b*b + 1) # choosing outer povar\n    zj = a + b*yj\n    theta = math.atan(-zj / (y1-yj)) * 180.0 / pi + (180.0 if yj>y1 else 0.0)\n    \n    return [0,theta] # return error, theta\n\ndef inverse(x0, y0, z0):\n    theta1 = 0\n    theta2 = 0\n    theta3 = 0\n    status = angle_yz(x0,y0,z0)\n\n    if status[0] == 0:\n        theta1 = status[1]\n        status = angle_yz(x0*cos120 + y0*sin120,\n                                   y0*cos120-x0*sin120,\n                                   z0,\n                                   theta2)\n    if status[0] == 0:\n        theta2 = status[1]\n        status = angle_yz(x0*cos120 - y0*sin120,\n                                   y0*cos120 + x0*sin120,\n                                   z0,\n                                   theta3)\n    theta3 = status[1]\n\n    return [status[0],theta1,theta2,theta3] \n \n 程式來源 :\xa0 [gist.github.com/hugs/4231272 \n \n', 'tags': '', 'url': '7月4號.html'}, {'title': '程式與正反向運動方程式', 'text': 'line 5 : \n import math \n 引入 math 庫 \n \n line9~12 : \n e  =  26.0\nf  =  69.0\nre = 128.0\nrf =  88.0 \n 機構長度 \n \n line15~22 : \n 三角函數 \n \n lline 32 : \n dtr = pi / 180.0 \n 徑度轉換 \n \n line 34~36 \n theta1 *= dtr\ntheta2 *= dtr\ntheta3 *= dtr \n \xa0*= 是python語法 ，指的是 θ = θ  \xa0*\xa0 pi / 180 \n \n \n line 51~53 \n w1 = y1*y1 + z1*z1\nw2 = x2*x2 + y2*y2 + z2*z2\nw3 = x3*x3 + y3*y3 + z3*z3 \n \n 計算各軸可觸碰到的範圍 \n W1、2、3指的是三軸最大極限構成的長方體 \n', 'tags': '', 'url': '程式與正反向運動方程式.html'}, {'title': '七月五號', 'text': '(接續七月四號主題) \n 為了瞭解運動矩之間的向量(包括不同平面間 ) 的關係，參考 :\xa0 \n https://www.youtube.com/watch?v=x7tkStus80U&feature=youtu.be \n \n \n \n 一開始在琢磨 line 31 行 : \n    t = (f-e) * tan30 / 2.0 \n 一開始不知道此行的 tan30 / 2 是怎麼來的，\xa0參考上面影片後，發現有一平面向量與其他力臂向量在 " 不同平面 "，所以需要用 轉換矩陣至不同平面上的方程式\xa0 轉換成同一平面上的向量方可推導公式 ， 所以此動作為帶入矩陣轉換方程式 。 \n \n \n \n 重點整理 :\xa0 \n', 'tags': '', 'url': '七月五號.html'}]};